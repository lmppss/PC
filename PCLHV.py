# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZkgJpsrPLf54vXV3wMqcJXu2RLl27OGj
"""

import streamlit as st
import numpy as np
import pandas as pd
import joblib
import datetime
import pytz
import plotly.graph_objects as go
import os
from io import BytesIO

# Cargar el modelo
modelo = joblib.load("PC_0.8722_12.04.pkl")

# Ruta para historial
historial_path = "historial_predicciones.csv"
if not os.path.exists(historial_path):
    pd.DataFrame(columns=["FechaHora", "Analista", "Cenizas", "PC", "PC real"]).to_csv(historial_path, index=False)

# TÃ­tulo
st.title("ğŸ”¥ PredicciÃ³n del Poder CalorÃ­fico del CarbÃ³n")
st.markdown("Ingrese los datos manualmente o pegue una fila completa separada por **coma, espacio o tabulaciÃ³n**.")

# Entrada rÃ¡pida
st.subheader("ğŸ“‹ Entrada rÃ¡pida (una lÃ­nea completa)")
entrada_linea = st.text_input("Pegue aquÃ­ una fila completa con los 11 valores en orden:")

# Inicializa el estado de entrada manual
if "mostrar_manual" not in st.session_state:
    st.session_state.mostrar_manual = False

if st.button("ğŸ“ Mostrar entrada manual"):
    st.session_state.mostrar_manual = not st.session_state.mostrar_manual

# Lista de analistas
analistas = sorted(["Giomara C.", "Walter G.", "Julio O.", "Jhony V.", "Kenyi A."]) + ["Otros"]
analista = st.selectbox("ğŸ‘¤ Seleccione el analista que realiza la predicciÃ³n:", analistas)

# Entrada manual
if st.session_state.mostrar_manual:
    cenizas_bs = st.number_input("Cenizas (BS) (%)", min_value=0.0)
    sio2 = st.number_input("SiO2 ash (%)", min_value=0.0)
    al2o3 = st.number_input("Al2O3 ash (%)", min_value=0.0)
    fe2o3 = st.number_input("Fe2O3 ash (%)", min_value=0.0)
    cao = st.number_input("CaO ash (%)", min_value=0.0)
    mgo = st.number_input("MgO ash (%)", min_value=0.0)
    so3 = st.number_input("SO3 ash (%)", min_value=0.0)
    na2o = st.number_input("Na2O ash (%)", min_value=0.0)
    k2o = st.number_input("K2O ash (%)", min_value=0.0)
    s_carbon = st.number_input("S carbÃ³n (%)", min_value=0.0)
    cl_carbon = st.number_input("Cl carbÃ³n (%)", min_value=0.0)

# ValidaciÃ³n
def validar_entrada(entrada):
    entrada = entrada.replace(",", ".")
    if entrada == "":
        return False
    try:
        valores = list(map(float, entrada.strip().split()))
        return len(valores) == 11
    except ValueError:
        return False

# BotÃ³n de predicciÃ³n
if st.button("ğŸ”® Predecir Poder CalorÃ­fico"):
    if entrada_linea:
        if not validar_entrada(entrada_linea):
            st.error("âš ï¸ Formato incorrecto. Ingrese exactamente 11 valores numÃ©ricos.")
            st.stop()

        sep = "," if "," in entrada_linea else "\t" if "\t" in entrada_linea else " "
        valores = list(map(float, entrada_linea.strip().split(sep)))
    else:
        valores = [cenizas_bs, sio2, al2o3, fe2o3, cao, mgo, so3, na2o, k2o, s_carbon, cl_carbon]

    valores_np = np.array(valores).reshape(1, -1)
    pc_predicho = modelo.predict(valores_np)[0]
    pc_entero = int(round(pc_predicho))

    st.success(f"ğŸ”¥ Poder CalorÃ­fico Predicho: **{pc_entero} kcal/kg**")

    ahora_lima = datetime.datetime.now(pytz.timezone('America/Lima'))
    nuevo = pd.DataFrame([{
        "FechaHora": ahora_lima.strftime('%Y-%m-%d %H:%M:%S'),
        "Cenizas": valores[0],
        "PC": pc_entero,
        "PC real": None,  # Inicialmente vacÃ­o
        "Analista": analista
    }])

    # Cargar historial
    historial = pd.read_csv(historial_path)

    # Asegurar que columnas necesarias existen
    if "PC real" not in historial.columns:
        historial["PC real"] = None

    # Concatenar nueva fila y guardar
    historial = pd.concat([historial, nuevo], ignore_index=True).tail(20)
    historial.to_csv(historial_path, index=False)

# Leer historial
historial = pd.read_csv(historial_path)

# Asegurar columnas
if "PC real" not in historial.columns:
    historial["PC real"] = None

# Calcular diferencia si hay PC real
historial["Diferencia"] = np.where(
    pd.to_numeric(historial["PC real"], errors='coerce').notna(),
    pd.to_numeric(historial["PC real"], errors='coerce') - historial["PC"],
    np.nan
)

# NUEVO BLOQUE ACTUALIZADO: Ingreso manual de PC real con alerta
st.subheader("ğŸ“ Ingresar PC real manualmente")

fechas_disponibles = historial[historial["PC real"].isna()]["FechaHora"].tolist()
if fechas_disponibles:
    fecha_seleccionada = st.selectbox("Seleccione la fecha de la predicciÃ³n:", fechas_disponibles, key="select_fecha")
    pc_real_input = st.number_input("Ingrese el PC real para esta fecha:", min_value=0, key="input_pc_real")
    if st.button("ğŸ“¥ Cargar PC real"):
        if pc_real_input > 0:
            historial.loc[historial["FechaHora"] == fecha_seleccionada, "PC real"] = pc_real_input

            # Recalcular la diferencia
            historial["Diferencia"] = np.where(
                pd.to_numeric(historial["PC real"], errors='coerce').notna(),
                pd.to_numeric(historial["PC real"], errors='coerce') - historial["PC"],
                np.nan
            )

            # Verificar diferencia absoluta
            diferencia_actual = historial.loc[historial["FechaHora"] == fecha_seleccionada, "Diferencia"].values[0]
            if abs(diferencia_actual) > 150:
                st.error(f"âš ï¸ Alerta: La diferencia entre el PC real y el predicho es de {diferencia_actual:.1f} kcal/kg, mayor al umbral de 150.")
            else:
                st.success(f"âœ… PC real de {fecha_seleccionada} actualizado a {pc_real_input} kcal/kg.")

            historial.to_csv(historial_path, index=False)
        else:
            st.warning("âš ï¸ Ingrese un valor vÃ¡lido para el PC real.")
else:
    st.info("ğŸ‰ No hay predicciones pendientes para actualizar PC real.")

# GrÃ¡fico
if not historial.empty:
    st.subheader("ğŸ“ˆ Historial de Predicciones (Ãºltimos 20)")
    historial["FechaHora"] = pd.to_datetime(historial["FechaHora"], errors='coerce')
    historial = historial.sort_values("FechaHora").tail(20)

    fig = go.Figure()

    fig.add_trace(go.Scatter(
        x=historial["FechaHora"],
        y=historial["PC"],
        mode="lines",
        name="Tendencia PC",
        line=dict(color="orange", width=2)
    ))

    fig.add_trace(go.Scatter(
        x=historial["FechaHora"],
        y=historial["PC"],
        mode="markers",
        name="Predicciones",
        marker=dict(
            size=historial["Cenizas"] * 2,
            color=historial["PC"],
            colorscale="YlOrRd",
            colorbar=dict(title="PC (kcal/kg)", len=0.75),
            showscale=True,
            line=dict(width=0.5, color='white')
        ),
        text=[
            f"Analista: {a}<br>PC: {pc:.0f} kcal/kg<br>Cenizas: {cen:.2f}%"
            for a, pc, cen in zip(historial["Analista"], historial["PC"], historial["Cenizas"])
        ],
        hoverinfo="text"
    ))

    fig.update_layout(
        title="Poder CalorÃ­fico vs Fecha (Ãºltimos 20 registros)",
        xaxis_title="Fecha y Hora",
        yaxis_title="Poder CalorÃ­fico (kcal/kg)",
        template="plotly_dark",
        hovermode="closest",
        height=500
    )

    st.plotly_chart(fig, use_container_width=True)

    # Tabla editable
    st.subheader("ğŸ—ƒï¸ Resumen de predicciones recientes (Ãºltimos 20)")

# Renombrar columnas para visualizaciÃ³n mÃ¡s clara
historial_df = historial[["FechaHora", "Analista", "Cenizas", "PC", "PC real", "Diferencia"]].copy()
historial_df = historial_df.rename(columns={
    "FechaHora": "ğŸ“… Fecha y Hora",
    "Analista": "ğŸ‘¤ Analista",
    "Cenizas": "ğŸŒ«ï¸ Cenizas (%)",
    "PC": "ğŸ”¥ PC Predicho",
    "PC real": "âœ… PC Real",
    "Diferencia": "ğŸ” Diferencia (kcal/kg)"
})

# Columna de eliminaciÃ³n como checkbox
historial_df["âŒ Eliminar"] = False

# Editor con mejoras visuales
edited_df = st.data_editor(
    historial_df,
    use_container_width=True,
    column_config={
        "ğŸ”¥ PC Predicho": st.column_config.NumberColumn(format="%.0f"),
        "âœ… PC Real": st.column_config.NumberColumn(format="%.0f"),
        "ğŸŒ«ï¸ Cenizas (%)": st.column_config.NumberColumn(format="%.2f"),
        "ğŸ” Diferencia (kcal/kg)": st.column_config.NumberColumn(format="%.1f"),
    },
    num_rows="dynamic",
    key="tabla_predicciones"
)

# Eliminar filas seleccionadas
if st.button("âŒ Eliminar seleccionadas"):
    eliminadas = edited_df[edited_df["âŒ Eliminar"] == True]
    if not eliminadas.empty:
        historial_df = edited_df[edited_df["âŒ Eliminar"] == False].drop(columns=["âŒ Eliminar"])
        historial_df.to_csv(historial_path, index=False)
        st.success(f"Se eliminaron {len(eliminadas)} predicciones.")
        st.rerun()
    else:
        st.warning("No se seleccionaron filas para eliminar.")


    # Descargar Excel
    st.subheader("ğŸ“¥ Descargar historial completo")
    df_completo = pd.read_csv(historial_path)
    buffer = BytesIO()
    with pd.ExcelWriter(buffer, engine='xlsxwriter') as writer:
        df_completo.to_excel(writer, index=False, sheet_name='Historial')
    st.download_button(
        label="ğŸ“„ Descargar en Excel",
        data=buffer.getvalue(),
        file_name="historial_predicciones.xlsx",
        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    )