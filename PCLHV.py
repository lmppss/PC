# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZkgJpsrPLf54vXV3wMqcJXu2RLl27OGj
"""

import streamlit as st
import numpy as np
import pandas as pd
import joblib
import datetime
import pytz
import plotly.graph_objects as go
import os
from io import BytesIO

# Cargar modelo
modelo = joblib.load("PC_0.8722_12.04.pkl")

# Ruta del historial
historial_path = "historial_predicciones.csv"
if not os.path.exists(historial_path):
    pd.DataFrame(columns=["FechaHora", "Analista", "Cenizas", "PC", "PC real"]).to_csv(historial_path, index=False)

# T√≠tulo y descripci√≥n
st.title("üî• Predicci√≥n del Poder Calor√≠fico del Carb√≥n")
st.markdown("Ingrese los datos manualmente o pegue una fila completa separada por **coma, espacio o tabulaci√≥n**.")

# Entrada r√°pida
st.subheader("üìã Entrada r√°pida")
entrada_linea = st.text_input("Pegue aqu√≠ una fila completa con los 11 valores en orden:")

# Mostrar entrada manual
if "mostrar_manual" not in st.session_state:
    st.session_state.mostrar_manual = False
if st.button("üìù Mostrar entrada manual"):
    st.session_state.mostrar_manual = not st.session_state.mostrar_manual

# Analista
analistas = sorted(["Giomara C.", "Walter G.", "Julio O.", "Jhony V.", "Kenyi A."]) + ["Otros"]
analista = st.selectbox("üë§ Analista:", analistas)

# Entrada manual
if st.session_state.mostrar_manual:
    cenizas_bs = st.number_input("Cenizas (BS) (%)", min_value=0.0)
    sio2 = st.number_input("SiO2 ash (%)", min_value=0.0)
    al2o3 = st.number_input("Al2O3 ash (%)", min_value=0.0)
    fe2o3 = st.number_input("Fe2O3 ash (%)", min_value=0.0)
    cao = st.number_input("CaO ash (%)", min_value=0.0)
    mgo = st.number_input("MgO ash (%)", min_value=0.0)
    so3 = st.number_input("SO3 ash (%)", min_value=0.0)
    na2o = st.number_input("Na2O ash (%)", min_value=0.0)
    k2o = st.number_input("K2O ash (%)", min_value=0.0)
    s_carbon = st.number_input("S carb√≥n (%)", min_value=0.0)
    cl_carbon = st.number_input("Cl carb√≥n (%)", min_value=0.0)

# Validaci√≥n de entrada r√°pida
def validar_entrada(entrada):
    entrada = entrada.replace(",", ".")
    try:
        valores = list(map(float, entrada.strip().replace(",", " ").replace("\t", " ").split()))
        return len(valores) == 11
    except:
        return False

# Bot√≥n de predicci√≥n
if st.button("üîÆ Predecir Poder Calor√≠fico"):
    if entrada_linea:
        if not validar_entrada(entrada_linea):
            st.error("‚ö†Ô∏è Ingrese exactamente 11 valores num√©ricos v√°lidos.")
            st.stop()
        valores = list(map(float, entrada_linea.strip().replace(",", " ").replace("\t", " ").split()))
    else:
        valores = [cenizas_bs, sio2, al2o3, fe2o3, cao, mgo, so3, na2o, k2o, s_carbon, cl_carbon]

    pc_predicho = modelo.predict(np.array(valores).reshape(1, -1))[0]
    pc_entero = int(round(pc_predicho))
    st.success(f"üî• Poder Calor√≠fico Predicho: **{pc_entero} kcal/kg**")

    ahora = datetime.datetime.now(pytz.timezone('America/Lima')).strftime('%Y-%m-%d %H:%M:%S')
    nuevo = pd.DataFrame([{
        "FechaHora": ahora,
        "Analista": analista,
        "Cenizas": valores[0],
        "PC": pc_entero,
        "PC real": None
    }])

    historial = pd.read_csv(historial_path)
    historial = pd.concat([historial, nuevo], ignore_index=True).tail(20)
    historial.to_csv(historial_path, index=False)

# Leer historial
historial = pd.read_csv(historial_path)
historial["Diferencia"] = np.where(
    pd.to_numeric(historial["PC real"], errors='coerce').notna(),
    pd.to_numeric(historial["PC real"], errors='coerce') - historial["PC"],
    np.nan
)

# Ingreso manual de PC real
st.subheader("üìù Ingresar PC real manualmente")
pendientes = historial[historial["PC real"].isna()]
if not pendientes.empty:
    fecha_sel = st.selectbox("Seleccione la predicci√≥n:", pendientes["FechaHora"].tolist())
    pc_real_input = st.number_input("Ingrese el PC real:", min_value=0, key="pc_real_input")
    if st.button("üì• Cargar PC real"):
        historial.loc[historial["FechaHora"] == fecha_sel, "PC real"] = pc_real_input
        historial["Diferencia"] = np.where(
            pd.to_numeric(historial["PC real"], errors='coerce').notna(),
            pd.to_numeric(historial["PC real"], errors='coerce') - historial["PC"],
            np.nan
        )
        historial.to_csv(historial_path, index=False)
        st.success(f"‚úÖ PC real actualizado para {fecha_sel}")
else:
    st.info("‚úÖ No hay predicciones pendientes de PC real.")

# Gr√°fico
st.subheader("üìà Historial de Predicciones")
historial["FechaHora"] = pd.to_datetime(historial["FechaHora"], errors='coerce')
historial = historial.sort_values("FechaHora").tail(20)

fig = go.Figure()
fig.add_trace(go.Scatter(
    x=historial["FechaHora"],
    y=historial["PC"],
    mode="lines+markers",
    name="Predicciones",
    marker=dict(
        size=historial["Cenizas"] * 2,
        color=historial["PC"],
        colorscale="YlOrRd",
        colorbar=dict(title="PC (kcal/kg)", len=0.6),
        line=dict(width=0.5, color='white')
    ),
    text=[
        f"Analista: {a}<br>PC: {p}<br>Cenizas: {c:.2f}%" for a, p, c in zip(historial["Analista"], historial["PC"], historial["Cenizas"])
    ],
    hoverinfo="text"
))
fig.update_layout(
    title="Poder Calor√≠fico vs Tiempo",
    xaxis_title="Fecha y Hora",
    yaxis_title="PC (kcal/kg)",
    height=500,
    template="plotly_dark"
)
st.plotly_chart(fig, use_container_width=True)

# Funci√≥n de estilo para diferencia
def aplicar_color_diferencia(val):
    if pd.isna(val):
        return ''
    elif abs(val) > 150:
        return 'background-color: red; color: white;'
    else:
        return 'background-color: green; color: white;'

# Mostrar historial con estilo
st.subheader("üóÉÔ∏è Tabla de predicciones")
historial_styled = historial.style.applymap(aplicar_color_diferencia, subset=["Diferencia"])
st.dataframe(historial_styled, use_container_width=True)

# Descargar historial
st.subheader("üì• Descargar historial")
buffer = BytesIO()
with pd.ExcelWriter(buffer, engine='xlsxwriter') as writer:
    historial.to_excel(writer, index=False, sheet_name="Historial")
st.download_button(
    label="üìÑ Descargar como Excel",
    data=buffer.getvalue(),
    file_name="historial_predicciones.xlsx",
    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
)