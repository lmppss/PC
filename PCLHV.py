# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZkgJpsrPLf54vXV3wMqcJXu2RLl27OGj
"""

import streamlit as st
import pandas as pd
import datetime
import pytz
import plotly.graph_objects as go
import os
from io import BytesIO

# Ruta para historial
historial_path = "historial_predicciones.csv"
if not os.path.exists(historial_path):
    pd.DataFrame(columns=["FechaHora", "Cenizas", "PC", "PC real", "Analista"]).to_csv(historial_path, index=False)

# Cargar historial
historial = pd.read_csv(historial_path)

# Asegurar que columnas necesarias existen
if "PC real" not in historial.columns:
    historial["PC real"] = None

# Calcular la diferencia si hay PC real
historial["Diferencia"] = np.where(
    pd.to_numeric(historial["PC real"], errors='coerce').notna(),
    pd.to_numeric(historial["PC real"], errors='coerce') - historial["PC"],
    np.nan
)

# Bot√≥n para ingresar PC real
if st.button("üí° Ingresar PC real"):
    # Selecci√≥n de fecha
    fechas_disponibles = historial[historial["PC real"].isna()]["FechaHora"].tolist()
    if fechas_disponibles:
        fecha_seleccionada = st.selectbox("Seleccione la fecha de la predicci√≥n:", fechas_disponibles)
        pc_real_input = st.number_input("Ingrese el PC real para esta fecha:", min_value=0)

        if st.button("üì• Cargar PC real"):
            if pc_real_input:
                # Actualizar el valor de "PC real" en el historial
                historial.loc[historial["FechaHora"] == fecha_seleccionada, "PC real"] = pc_real_input

                # Rec√°lculo de la diferencia
                historial["Diferencia"] = np.where(
                    pd.to_numeric(historial["PC real"], errors='coerce').notna(),
                    pd.to_numeric(historial["PC real"], errors='coerce') - historial["PC"],
                    np.nan
                )

                # Guardar el historial actualizado en CSV
                historial.to_csv(historial_path, index=False)
                st.success(f"PC real de {fecha_seleccionada} actualizado a {pc_real_input} kcal/kg.")
            else:
                st.warning("Por favor, ingrese un valor v√°lido para el PC real.")
    else:
        st.info("No hay predicciones pendientes de PC real para actualizar.")

# Rec√°lculo de la diferencia
historial["Diferencia"] = np.where(
    pd.to_numeric(historial["PC real"], errors='coerce').notna(),
    pd.to_numeric(historial["PC real"], errors='coerce') - historial["PC"],
    np.nan
)

# Mostrar gr√°fico de historial
if not historial.empty:
    st.subheader("üìà Historial de Predicciones (√∫ltimos 20)")
    historial["FechaHora"] = pd.to_datetime(historial["FechaHora"], errors='coerce')
    historial = historial.sort_values("FechaHora").tail(20)

    fig = go.Figure()

    fig.add_trace(go.Scatter(
        x=historial["FechaHora"],
        y=historial["PC"],
        mode="lines",
        name="Tendencia PC",
        line=dict(color="orange", width=2)
    ))

    fig.add_trace(go.Scatter(
        x=historial["FechaHora"],
        y=historial["PC"],
        mode="markers",
        name="Predicciones",
        marker=dict(
            size=historial["Cenizas"] * 2,
            color=historial["PC"],
            colorscale="YlOrRd",
            colorbar=dict(title="PC (kcal/kg)", len=0.75),
            showscale=True,
            line=dict(width=0.5, color='white')
        ),
        text=[
            f"Analista: {a}<br>PC: {pc:.0f} kcal/kg<br>Cenizas: {cen:.2f}%"
            for a, pc, cen in zip(historial["Analista"], historial["PC"], historial["Cenizas"])
        ],
        hoverinfo="text"
    ))

    fig.update_layout(
        title="Poder Calor√≠fico vs Fecha (√∫ltimos 20 registros)",
        xaxis_title="Fecha y Hora",
        yaxis_title="Poder Calor√≠fico (kcal/kg)",
        template="plotly_dark",
        hovermode="closest",
        height=500
    )

    st.plotly_chart(fig, use_container_width=True)

    # Tabla editable
    st.subheader("üóÉÔ∏è Resumen de predicciones recientes (√∫ltimos 20)")

    historial_df = historial[["FechaHora", "Cenizas", "PC", "PC real", "Diferencia", "Analista"]]
    historial_df["Eliminar"] = False
    edited_df = st.data_editor(historial_df, num_rows="dynamic", use_container_width=True)

    if st.button("‚ùå Eliminar seleccionadas"):
        eliminadas = edited_df[edited_df["Eliminar"] == True]
        if not eliminadas.empty:
            historial_df = edited_df[edited_df["Eliminar"] == False].drop(columns=["Eliminar"])
            historial_df.to_csv(historial_path, index=False)
            st.success(f"Se eliminaron {len(eliminadas)} predicciones.")
            st.rerun()
        else:
            st.warning("No se seleccionaron filas para eliminar.")

    # Descargar Excel
    st.subheader("üì• Descargar historial completo")
    df_completo = pd.read_csv(historial_path)
    buffer = BytesIO()
    with pd.ExcelWriter(buffer, engine='xlsxwriter') as writer:
        df_completo.to_excel(writer, index=False, sheet_name='Historial')
    st.download_button(
        label="üìÑ Descargar en Excel",
        data=buffer.getvalue(),
        file_name="historial_predicciones.xlsx",
        mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    )